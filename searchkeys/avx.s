// Code generated by command: go run avx_ignore.go -out avx.s -stubs stubs_avx.go. DO NOT EDIT.

#include "textflag.h"

// func AVXSearch(xs []uint64, key uint64) int16
// Requires: AVX, AVX2, BMI
TEXT Â·AVXSearch(SB), NOSPLIT, $32-34
	// n
	MOVL xs_len+8(FP), AX

	// xs[0]
	MOVQ xs_base+0(FP), CX

	// key
	VPBROADCASTQ key+24(FP), Y0

	// load const 4 into a register; load n as max
	MOVL $0x00000004, BX
	MOVL xs_len+8(FP), DX

	// i := 0
	XORL BP, BP
	NOP
	JMP  loop

plusplus:
	// i+=8
	ADDL $0x08, BP

	// For loop starts
loop:
	CMPL BP, AX
	JGE  NotFound

	// Copy 4 keys into packed
	MOVQ (CX)(BP*8), DX
	MOVQ DX, (SP)
	MOVQ 16(CX)(BP*8), DX
	MOVQ DX, 8(SP)
	MOVQ 32(CX)(BP*8), DX
	MOVQ DX, 16(SP)
	MOVQ 48(CX)(BP*8), DX
	MOVQ DX, 24(SP)

	// Move the packed keys into ymm; move key into pk
	VMOVUPD (SP), Y1

	// Check GTE
	VPCMPEQQ Y1, Y0, Y2
	VPCMPGTQ Y0, Y1, Y1
	VPADDQ   Y2, Y1, Y1

	// Move result out
	VMOVMSKPD Y1, DX

	// Count trailing zeroes XX
	TZCNTL DX, DX

	// if tz < 4 we got a result
	CMPL DX, BX
	JGE  plusplus

	// we've found the results in XX
	// 2*tz + i
	SHLL $0x01, DX
	ADDL BP, DX

	// div by 2
	MOVL DX, BP
	SHRL $0x1f, BP
	ADDL BP, DX
	SARL $0x01, DX
	MOVL DX, ret+32(FP)
	RET

NotFound:
	// Load len as a 64 bit number
	MOVQ xs_len+8(FP), CX

	// return n/2
	MOVQ CX, AX
	SHRQ $0x3f, CX
	ADDQ AX, CX
	SARQ $0x01, CX
	MOVQ CX, ret+32(FP)
	RET
