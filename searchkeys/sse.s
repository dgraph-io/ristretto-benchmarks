// Code generated by command: go run sse_ignore.go -out sse.s -stubs stubs_sse.go. DO NOT EDIT.

#include "textflag.h"

// func SSESearch(xs []uint64, key uint64) int16
// Requires: AVX, AVX2, SSE, SSE2
TEXT Â·SSESearch(SB), NOSPLIT, $32-34
	// n
	MOVL xs_len+8(FP), AX

	// xs[0]
	MOVQ xs_base+0(FP), CX

	// key
	MOVL         $0xffffffff, BP
	VPBROADCASTQ key+24(FP), X0

	// load const 4 into a register; load n as max
	MOVL $0x00000004, DX
	MOVL xs_len+8(FP), DX

	// i := 0
	XORL SI, SI
	NOP
	JMP  loop

plusplus:
	// i+=4
	ADDL $0x04, SI

	// For loop starts
loop:
	CMPL SI, AX
	JGE  NotFound

	// Copy 4 keys into packed
	MOVQ (CX)(SI*8), DX
	MOVQ DX, (SP)
	MOVQ 16(CX)(SI*8), DX
	MOVQ DX, 8(SP)

	// Move the packed keys into ymm; move key into pk
	MOVUPS (SP), X1

	// Check GTE
	VPCMPEQQ X1, X0, X2
	VPCMPGTQ X0, X1, X1
	VPADDQ   X2, X1, X1

	// Move result out
	MOVQ       X1, DX
	PUNPCKHQDQ X1, X1
	MOVQ       X1, BX
	CMPL       BP, DX
	JE         FoundFst
	CMPL       BP, BX
	JNE        plusplus
	MOVL       $0x00000001, AX
	JMP        Found

FoundFst:
	MOVL $0x00000000, AX

Found:
	// we've found the results in fst
	// 2*xx + i
	SHLL $0x01, AX
	ADDL SI, AX

	// div by 2
	MOVL AX, SI
	SHRL $0x1f, SI
	ADDL SI, AX
	SARL $0x01, AX
	MOVL AX, ret+32(FP)
	RET

NotFound:
	// Load len as a 64 bit number
	MOVQ xs_len+8(FP), CX

	// return n/2
	MOVQ CX, AX
	SHRQ $0x3f, CX
	ADDQ AX, CX
	SARQ $0x01, CX
	MOVQ CX, ret+32(FP)
	RET
